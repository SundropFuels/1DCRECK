'''
Created on May 31, 2011

@author: root
'''
import csv
import re
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D    #for 3D plotting
from matplotlib.ticker import LinearLocator, FixedLocator, FormatStrFormatter    #for 3D plotting

class PlottingToolbox:
    """
        This class contains the methods for plotting data read from the csv file generated during simulation.
        Upon initialization, the class reads the csv file and puts the data into a dictionary.  plotCount is a Class
        attribute that is used to assign figure numbers
    """
    plotCount = 0
    def __init__(self,exitFile = '/home/jordan/code/python/simulationResults.csv',profileFile = '/home/jordan/code/python/profileResults.csv'):

        #Read in csv files generated by the BiomassSolver 
        #GET ALL OF THE EXIT DATA AND PUT IT IN A DICTIONARY
        exitIndexDict = {}
        self.exitDataDict = {}
        exitFile = open(exitFile, 'rb')
        profileFile = open(profileFile, 'rb')
        exitReader = csv.reader(exitFile)
        exitHeader = exitReader.next()
        exitReader = csv.reader(exitFile,delimiter = ',',quoting = csv.QUOTE_NONNUMERIC)
        #Track the index of each column based on its name and create a dictionary mapping column name to index
        for i in range(len(exitHeader)):
            exitIndexDict[exitHeader[i]] = i 
            self.exitDataDict[exitHeader[i]] = []
        for row in exitReader:
            for key,value in exitIndexDict.items():
                self.exitDataDict[key].append(row[value])
        exitFile.close()
        #MAP THE FOLLOWING KEYS TO OTHER DICTIONARIES CONTAINING PHASE OR SPECIES VALUES
        self.exitDataDict['Phase Temperatures [C]'] = dict((k,v) for (k,v) in self.exitDataDict.items() if 'Temperature' in k and 'Wall' not in k)
        self.exitDataDict['Concentration [Mole Fraction]'] = dict((k,v) for (k,v) in self.exitDataDict.items() if 'Concentration' in k)
        self.exitDataDict['Concentration [Mole Fraction]'] = dict((re.sub('\Concentraion','',k),v) for (k,v) in self.exitDataDict['Concentration [Mole Fraction]'].items())
        self.exitDataDict['Molar Rate [mol/min]'] = dict((k,v) for (k,v) in self.exitDataDict.items() if 'mol/min' in k)
        self.exitDataDict['Molar Rate [mol/min]'] = dict((k.strip('mol/min'),v) for (k,v) in self.exitDataDict['Molar Rate [mol/min]'].items())


        #Three Dictionaries are created to handle cutting up the profile data into 2D lists (each list represents a profile)
        #This is implemented such that the final dictionary will contain key value pairs of column name: 2D list of data
        profileIndexDict = {}
        profileDataDict1 = {}
        profileDataDict2 = {}
        self.profileDataDict3 = {}
        runIDList = [] # runIDList is used as the reference to determine when one profile ends and another begins
        profileReader = csv.reader(profileFile)
        profileHeader = profileReader.next()
        profileReader = csv.reader(profileFile,delimiter = ',',quoting = csv.QUOTE_NONNUMERIC)
        #Create empty lists mapped to each column header name
        for i in range(len(profileHeader)):
            profileIndexDict[profileHeader[i]] = i
            profileDataDict1[profileHeader[i]] = []
            profileDataDict2[profileHeader[i]] = []
            self.profileDataDict3[profileHeader[i]] = []
        
        #Create the initial dictionary containing all of the data and the runIDList
        for row in profileReader:
            runIDList.append(row[profileIndexDict['RunID']])
            for key, value in profileIndexDict.items():
                profileDataDict1[key].append(row[value])
        profileFile.close()
        
        #Cut the data up into lists for each profile.  The final result is a dictionary mapping
        #of column name : 2D list of profiles.
        for key, value in profileDataDict1.items():   #value is the long list of profile data
            for i in range(len(runIDList)-1):
                profileDataDict2[key].append(value[i])
                if runIDList[i] != runIDList[i+1]:
                    self.profileDataDict3[key].append(profileDataDict2[key])
                    profileDataDict2[key] = []
                elif i == (len(runIDList) - 2):
                    profileDataDict2[key].append(value[i+1])
                    self.profileDataDict3[key].append(profileDataDict2[key])
         
        #MAP THE FOLLOWING KEYS TO OTHER DICTIONARIES CONTAINING PHASE OR SPECIES VALUES            
        self.profileDataDict3['Phase Temperatures [C]'] = dict((k,v) for (k,v) in self.profileDataDict3.items() if 'Temperature' in k and 'Wall' not in k)
        #Should be able to get concentrations in a one liner with the regular expression
        self.profileDataDict3['Concentrations [Mole Fractions]'] = dict((k,v) for (k,v) in self.profileDataDict3.items() if 'Concentration' in k and 'N- ' not in k)
        self.profileDataDict3['Concentrations [Mole Fractions]']= dict((re.sub('\Concentration','',k),v) for (k,v) in self.profileDataDict3['Concentrations [Mole Fractions]'].items())
        self.profileDataDict3['Molar Rates [mol/min]'] = dict((k,v) for (k,v) in self.profileDataDict3.items() if 'mol/min' in k)

    def plot2D(self,dataList,figureDirectory = None): 
        """
            plotData generates a plot from the given list of x and y data in the form:
            [x1,y1].  labels and titles are created based
            on the data selected to plot.  x and y are strings that map to keys in self.dataDict
            
        """
        PlottingToolbox.plotCount += 1
        NUM_COLORS = 15
        cm = plt.get_cmap('Set1')
        colorIndex = 0
        #for set in dataList
        fig = plt.figure(PlottingToolbox.plotCount,figsize = (20,10))
        if dataList[2] != '':
            xdata = self.exitDataDict[dataList[0]][dataList[2]]
            xlabel = plt.xlabel(dataList[2]+ ' '+ dataList[0])
        else:
            xdata = self.exitDataDict[dataList[0]]
            xlabel = plt.xlabel(dataList[0])
            
        if dataList[3] != '':
            ydata = self.exitDataDict[dataList[1]][dataList[3]]
            ylabel = plt.ylabel(dataList[3] + ' ' + dataList[1])
        else:
            ydata = self.exitDataDict[dataList[1]]
            ylabel = plt.ylabel(dataList[1])
        
        plt.plot(xdata,ydata)
        title = plt.suptitle(dataList[1]+ ' versus ' + dataList[0])
        plt.savefig(figureDirectory + (dataList[1]+ ' versus ' + dataList[0]).replace('/','_') + '.jpeg')
        plt.show()
    
    #Find way to implement multiple plots on a figure with a legend
        
    def plotProfile(self,profile,figureDirectory = None):
        """
            Plot the appropriate profile depending which ones were selected on the GUI front end.
        """
        
        NUM_COLORS = 15
        cm = plt.get_cmap('Set1')
        colorIndex = 0
        try:
            xdata = self.profileDataDict3['Distance']
            #Dictionary values could either be lists or dictionaries.  This if statement enforces a single type
            #of y-data, a dictionary.
            if type(self.profileDataDict3[profile]) == list:
                ydata = dict((k,v) for k,v in self.profileDataDict3.items() if k == profile)
            elif type(self.profileDataDict3[profile]) == dict:
                ydata = self.profileDataDict3[profile]

            for i in range(len(xdata)):   #Loop through the data for each simulation (1,2,3,4,etc..)
                for k in ydata.keys():    #Loop through each profile ('Gas Temperature','Solid Temperature',etc...)
                    fig = plt.figure(PlottingToolbox.plotCount,figsize = (20,10))
                    color = cm(1.*colorIndex/NUM_COLORS)  # color will now be an RGBA tuple
                    if profile == 'Concentrations [Mole Fractions]':
                        if ydata[k][i][-1]> 0.001:
                            plt.plot(xdata[i],ydata[k][i],label = k,color = color,linewidth = 2.0)
                            colorIndex += 1
                    elif profile == 'Molar Rates [mol/min]':
                        if ydata[k][i][-1] > 0.0001:
                            plt.plot(xdata[i],ydata[k][i],label = k, color = color, linewidth = 2.0)
                            colorIndex += 1        
                    else:
                        plt.plot(xdata[i],ydata[k][i],label = k,color = color,linewidth = 2.0)
                        colorIndex += 1
                PlottingToolbox.plotCount += 1
                colorIndex = 0
                xlabel = plt.xlabel('Distance [m]')
                ylabel = plt.ylabel(profile)
                title = plt.suptitle(profile + ' Profile' + ' %s'%i)
                legend = plt.legend(loc='upper right')
            plt.savefig(figureDirectory + profile.replace('/','_') + ' Profile' + ' %s'%i + '.png')
            plt.show() 
            
        except KeyError,errormessage:
            print errormessage, ' Was not a simulated profile'
            
        
                   
if __name__ == '__main__':
    plotter = PlottingToolbox(exitFile = '/home/jordan/code/python/simulationResults.csv',profileFile = '/home/jordan/code/python/profileResults.csv')
    plotter.plotProfile('solids Temperature')